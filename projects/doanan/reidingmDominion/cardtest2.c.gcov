        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include <stdlib.h>
        -:    7:#include <string.h>
        -:    8:
function main called 2 returned 100% blocks executed 74%
        2:    9:int main(){
        -:   10:
        -:   11:	int i, j; 					 	// counter
        -:   12:	int p, p2;					// indicating which player
        -:   13:	int pos;					// position
        -:   14:	int played;					// number of cards played from deck
        -:   15:	int deckSize;				// size of deck
        -:   16:	int odecksize;				// other player's deck size
        -:   17:	int pileSize;				// pile of usable cards
        2:   18:	int numPlayers = 2;  		// players for valid gamestate
        2:   19:	int numTests = 1; 			// large testing spread
        -:   20:	int amount;					// total value of accumulated coins
        -:   21:	int totalDrawn;				// cards drawn before +2 coins, should be discarded by end
        -:   22:	int drawnTreasure;			// treasure card counter
        -:   23:	struct gameState g;			// gamestate, original
        -:   24:	struct gameState testState;		// gamestate under test
        2:   25:	int k[10] = {duchy, gardens, province, estate, tribute, mine, cutpurse, ambassador, great_hall, adventurer};
        2:   26:	char testCard[] = "adventurer";	 // card under test
        -:   27:
        -:   28:
        -:   29:
        2:   30:	printf("---     TESTING CARD: %s    ---\n\n ", testCard);
call    0 returned 100%
        -:   31:	
        4:   32:	for(i = 0; i < numTests; i++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:   33:		
        -:   34:		// set hand basics for each game so the function can be called
        2:   35:		pos = -1;
        2:   36:		p = 0;
        2:   37:		p2 = 1;
        -:   38:
        -:   39:		// copy into a test state so I don't destroy the world
        2:   40:		initializeGame(numPlayers, k, 1000, &g);
call    0 returned 100%
        2:   41:		memcpy(&testState, &g, sizeof(struct gameState));
        -:   42:
        -:   43:
        -:   44:		// begin test
        2:   45:		deckSize = testState.handCount[p];										// how many are originally in hand before play
        2:   46:		odecksize = testState.deckCount[p2];									// how many are originall in other's hand before play
        2:   47:		played = testState.handCount[p] - testState.discardCount[p];			// how many cards were played
        2:   48:		pileSize = testState.deckCount[p];										// pile of non-trashed cards before play
        2:   49:		totalDrawn = 0;															// amount drawn to get to 2 coin cards
        2:   50:		drawnTreasure = 0;														// number of coin cards drawn
        2:   51:		amount = 0;																// value of accumulated coin cards
        -:   52:		int preCount;
        -:   53:		
        -:   54:		// test to make sure cards are drawn until two coin cards
        -:   55:		// will show if less than or more than is allowed due to error
        2:   56:		printf("\nTest 1: Play Adventurer and draw until two coins are drawn:\n");
call    0 returned 100%
        2:   57:		initializeGame(numPlayers, k, 1000, &g);
call    0 returned 100%
        2:   58:		memcpy(&testState, &g, sizeof(struct gameState));
        2:   59:		testState.hand[p][0] = adventurer;
        2:   60:		testState.hand[p][1] = duchy;
        2:   61:		testState.hand[p][2] = estate;
        2:   62:		testState.hand[p][3] = province;
        2:   63:		testState.hand[p][4] = gardens;
        2:   64:		testState.deck[p][0] = copper;
        2:   65:		testState.deck[p][1] = silver;
        2:   66:		testState.deck[p][2] = gold;
        2:   67:		testState.deck[p][3] = copper;
        2:   68:		testState.deck[p][4] = silver;
        2:   69:		preCount = testState.handCount[p];
        2:   70:		cardEffect(adventurer, 0, 0, 0, &testState, 0, 0);		// should have two coin cards when done
call    0 returned 100%
        2:   71:		if(testState.handCount[p] - preCount == 2) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   72:			printf("Passed. Coin card amount expected: %d   count finish: %d\n", 2, testState.handCount[p] - preCount);
call    0 never executed
        -:   73:		else 
        2:   74:			printf("FAILED. Coin card amount expeccted: %d   count finish: %d\n", 2, testState.handCount[p] - preCount);
call    0 returned 100%
        2:   75:		printf("Coin cards Found: ");
call    0 returned 100%
       14:   76:		for(j = 0; j < testState.handCount[p]; j++){
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
       12:   77:			if(testState.hand[p][j] == copper){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   78:				printf("copper, ");
call    0 never executed
    #####:   79:				amount += 1;
        -:   80:			}
       12:   81:			if(testState.hand[p][j] == silver){
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        2:   82:				printf("silver, ");
call    0 returned 100%
        2:   83:				amount += 2;
        -:   84:			}
       12:   85:			if(testState.hand[p][j] == gold){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   86:				printf("gold, ");
call    0 never executed
    #####:   87:				amount += 3;
        -:   88:			}
        -:   89:		}
        -:   90:
        -:   91:		// test to make sure the value provided is right
        2:   92:		printf("\nTest 1b: Gained cards, coin ammount unchanged till use:\n");
call    0 returned 100%
        2:   93:		if(g.coins == testState.coins)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:   94:			printf("Passed. Coin amount the same\n");
call    0 returned 100%
        -:   95:		else
    #####:   96:			printf("FAILED. Coin amount different\n");
call    0 never executed
        -:   97:
        -:   98:
        2:   99:		printf("\nTest 1c: Check test one again, but with gold drawn:\n");
call    0 returned 100%
        2:  100:		initializeGame(numPlayers, k, 1000, &g);
call    0 returned 100%
        2:  101:		memcpy(&testState, &g, sizeof(struct gameState));
        2:  102:		testState.hand[p][0] = adventurer;
        2:  103:		testState.hand[p][1] = duchy;
        2:  104:		testState.hand[p][2] = estate;
        2:  105:		testState.hand[p][3] = province;
        2:  106:		testState.hand[p][4] = gardens;
        2:  107:		testState.deck[p][0] = gold;
        2:  108:		testState.deck[p][1] = silver;
        2:  109:		testState.deck[p][2] = gold;
        2:  110:		testState.deck[p][3] = copper;
        2:  111:		testState.deck[p][4] = gold;
        2:  112:		preCount = testState.handCount[p];
        2:  113:		cardEffect(adventurer, 0, 0, 0, &testState, 0, 0);		// should have two coin cards when done
call    0 returned 100%
        -:  114:		
        2:  115:		if(testState.handCount[p] - preCount == 2) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  116:			printf("Passed. Coin card amount expected: %d   count finish: %d\n", 2, testState.handCount[p] - preCount);
call    0 never executed
        -:  117:		else 
        2:  118:			printf("FAILED. Coin card amount expeccted: %d   count finish: %d\n", 2, testState.handCount[p] - preCount);
call    0 returned 100%
        2:  119:		printf("Coin cards Found: ");
call    0 returned 100%
       14:  120:		for(j = 0; j < testState.handCount[p]; j++){
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
       12:  121:			if(testState.hand[p][j] == copper){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  122:				printf("copper, ");
call    0 never executed
    #####:  123:				amount += 1;
        -:  124:			}
       12:  125:			if(testState.hand[p][j] == silver){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  126:				printf("silver, ");
call    0 never executed
    #####:  127:				amount += 2;
        -:  128:			}
       12:  129:			if(testState.hand[p][j] == gold){
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        2:  130:				printf("gold, ");
call    0 returned 100%
        2:  131:				amount += 3;
        -:  132:			}
        -:  133:		}
        -:  134:
        -:  135:		// check to make sure drawnTreasure is matching amount of distributed coin cards
        2:  136:		initializeGame(numPlayers, k, 1000, &g);
call    0 returned 100%
        2:  137:		memcpy(&testState, &g, sizeof(struct gameState));
        2:  138:		testState.hand[p][0] = adventurer;
        2:  139:		testState.hand[p][1] = duchy;
        2:  140:		testState.hand[p][2] = estate;
        2:  141:		testState.hand[p][3] = province;
        2:  142:		testState.hand[p][4] = gardens;
        2:  143:		testState.deck[p][0] = gardens;
        2:  144:		testState.deck[p][1] = silver;
        2:  145:		testState.deck[p][2] = gold;
        2:  146:		testState.deck[p][3] = copper;
        2:  147:		testState.deck[p][4] = duchy;
        2:  148:		cardEffect(adventurer, 0, 0, 0, &testState, 0, 0);	
call    0 returned 100%
        -:  149:
        2:  150:		printf("\nTest 2: Make sure all cards were discarded that were not coins:\n");
call    0 returned 100%
        2:  151:		if(1 == testState.discardCount[p]) // will gain one non-coincard prior to 2 with this deck
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  152:			printf("Passed. Expected discard amount: %d   Discarded finish: %d\n", 1, testState.discardCount[p]);
call    0 returned 100%
        -:  153:		else
    #####:  154:			printf("FAILED. Expected disccard amount: %d  Discarded finish: %d\n", 1, testState.discardCount[p]);
call    0 never executed
        -:  155:		
        -:  156:
        -:  157:		//test to make sure the other player's hand didn't change. No cards given, none taken from
        2:  158:		printf("\nTest 3: Other player's deck size unchanged when adventurer is drawn:\n");
call    0 returned 100%
        2:  159:		if(testState.deckCount[p2] == odecksize)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  160:			printf("Passed. Deck size start: %d   Deck size finish: %d\n", odecksize, testState.deckCount[p2]);
call    0 returned 100%
        -:  161:		else
    #####:  162:			printf("FAILED. Deck size start: %d   Deck size finish: %d\n", odecksize, testState.deckCount[p2]);
call    0 never executed
        -:  163:
        -:  164:
        -:  165:		//test to make sure the other player's hand didn't change. No cards given, none taken from
        2:  166:		printf("\nTest 3b: Other player's hand size unchanged when adventurer is drawn:\n");
call    0 returned 100%
        2:  167:		if(testState.handCount[p2] == g.handCount[p2])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  168:			printf("Passed. Hand size start: %d   Hand size finish: %d\n", g.handCount[p2], testState.handCount[p2]);
call    0 returned 100%
        -:  169:		else
    #####:  170:			printf("FAILED. Hand size start: %d   Hand size finish: %d\n", g.handCount[p2], testState.handCount[p2]);
call    0 never executed
        -:  171:
        -:  172:
        -:  173:		//test to make sure the cards come from own player's pile, and is not stealing from elsewhere
        2:  174:		printf("\nTest 4: Player is drawing and keeping only two cards from own pile:\n");
call    0 returned 100%
        2:  175:		if(g.deckCount[p] -3 == testState.deckCount[p]) // -1 bc of this hand, has one noncoin card pulled
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  176:			printf("Passed. Expected: %d   Deck size finish: %d\n", g.deckCount[p] - 3, testState.deckCount[p]);
call    0 never executed
        -:  177:		else
        2:  178:			printf("FAILED. Expected: %d   Deck size finish: %d\n", g.deckCount[p] - 3, testState.deckCount[p]);
call    0 returned 100%
        -:  179:
        -:  180:		//test to make sure the card is going to the played pile after use. Already established other players deck is unchanged
        2:  181:		printf("\nTest 5: Adventurer card added to played pile after use:\n");
call    0 returned 100%
        2:  182:		if(testState.playedCardCount == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  183:			printf("Passed. Expected increase in played pile: %d     To played pile: %d\n", 1, testState.playedCardCount);
call    0 never executed
        -:  184:		else
        2:  185:			printf("FAILED. Expected increase in played pile: %d   To played pile: %d\n", 1, testState.playedCardCount);
call    0 returned 100%
        -:  186:
        -:  187:		// test for changes in money supply that shouldn't have been activated, will test for money being given to players
        2:  188:		printf("\nTest 6: Test supply counts for treasure that should have been distributed: \n");
call    0 returned 100%
        2:  189:		if(g.supplyCount[copper] != testState.supplyCount[copper])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  190:			printf("FAILED. Estate Count Mismatch. Expected: %d  Received: %d\n", g.supplyCount[copper], testState.supplyCount[copper]);
call    0 never executed
        2:  191:		if(g.supplyCount[silver] != testState.supplyCount[silver])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  192:			printf("FAILED. Duchy Count Mismatch. Expected: %d  Received: %d\n", g.supplyCount[silver], testState.supplyCount[silver]);
call    0 never executed
        2:  193:		if(g.supplyCount[gold] != testState.supplyCount[gold])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  194:			printf("FAILED. Duchy Count Mismatch. Expected: %d  Received: %d\n", g.supplyCount[gold], testState.supplyCount[gold]);
call    0 never executed
        -:  195:		else
        2:  196:			printf("Passed. Supply counts for treasure cards are the same\n");
call    0 returned 100%
        -:  197:		
        -:  198:		//test for world state changes, will indicate if any victory cards have been given out inappropriately
        2:  199:		printf("\nTest 7: : Test supply counts for points and curses that should not have been distributed: \n ");
call    0 returned 100%
        2:  200:		if(g.supplyCount[estate] != testState.supplyCount[estate])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  201:			printf("FAILED. Estate Count Mismatch. Expected: %d  Received: %d\n", g.supplyCount[estate], testState.supplyCount[estate]);
call    0 never executed
        2:  202:		if(g.supplyCount[duchy] != testState.supplyCount[duchy])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  203:			printf("FAILED. Duchy Count Mismatch. Expected: %d  Received: %d\n", g.supplyCount[duchy], testState.supplyCount[duchy]);
call    0 never executed
        2:  204:		if(g.supplyCount[province] != testState.supplyCount[province])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  205:			printf("FAILED. Province Count Mismatch. Expected: %d  Received: %d\n", g.supplyCount[province], testState.supplyCount[province]);
call    0 never executed
        2:  206:		if(g.supplyCount[curse] != testState.supplyCount[curse])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  207:			printf("FAILED. Province Count Mismatch. Expected: %d  Received: %d\n", g.supplyCount[curse], testState.supplyCount[curse]);
call    0 never executed
        -:  208:		else
        2:  209:			printf("Passed. Supply counts for curses and victory cards are the same\n");
call    0 returned 100%
        -:  210:
        -:  211:	}
        -:  212:
        2:  213:	return 0;
        -:  214:}
